"""
finalprojectlib- library of classes for final project

Noah Schwartzapfel
"""
import numpy as np # for general number business
import xml.etree.ElementTree as ET # for parsing XML files
import io # for handling byte data
from pathlib import Path # for raw data inputs from local paths (used in test case only)
from plotly.subplots import make_subplots # for making plots
import scipy.constants as cnst # for unit conversions
import plotly.colors as pc # color palette for plots
from copy import deepcopy # for complete copies data series
import zipfile # for generating zip files
import pandas as pd # for writing arrays to CSVs
 
class DataWrapper:
    """
    DataWrapper objects accept the raw XML data and parse and format the data.

    Constructor:
        DataWrapper(raw: str or pathlib.Path, **kwargs):
            raw (default None): specifies path of raw XML file
            **kwargs: extra keyword arguments to save to object as attributes at construction-time
    
    Attributes:
        raw (str, pathlib.Path, or streamlit.UploadFile): specifies path of raw XML file
        
        *attributes below generated by DataWrapper.parseData()
        x (list of numpy.array): parsed wavelength data
        y (list of numpy.array): parsed absorbance data
        names (list of str): names of each data series
        minX (list of float): minimum wavelength values for each trace

        *attributes below generated by DataWrapper.formatData()
        plotX (list of numpy.array): normalized and formatted x-axis data
        plotY (list of numpy.array): normalized and formatted absorbance data
        units (str): name of units used (wavelength, wavenumbers, etc.)
        maxWLs (list of str): list of wavelengths of maximum absorbance for each data series
    
    Methods:
        update(**kwargs): updates/sets attribute corresponding to keyword in kwargs to specified value
        parseData: processes raw data file and returns x, y and names
        
        formatData: processes raw wavelength and absorbance data according to normalization and range preferences and outputs data to plot
            Keyword arguments:
                xRange_in_nm (list, tuple, or numpy.array of float or None, default: None)
                    defines what range to plot over on x-axis (must be in nm),
                    if None, whole x-axis range is plotted
                
                normalize (bool, default: True)
                    whether to carry out normalization

                normRange (list, or list of lists, or None: default: None):
                    defines what range to search for max absorbance to normalize against:
                    
                    if a single range is provided, this will be applied to all traces,
                    
                    if multiple ranges are provided, number of ranges must be equal to number of traces,
                    and each range will be applied to each trace in order

                    if None, no normalization (*this necessitates normalize = False*)
                
                aboveZero (bool or None, default: True):
                    whether to set minima of all traces to 0, used if absorbances go below 0
                
                inclusion (list of bool or None, default: None):
                    defines which traces to include in final plot, if None, all traces are included
        
        makeFolder: generates zip folder of CSVs of formatted data series
        
        setPlotTitles: fetches journal entries associated with data
            (e.g. CJJ-I-001-A-2, CJJ-I-001-A-3, CJJ-II-344-B, CJJ-II-776-cr
            would return ["CJJ-I-001", "CJJ-II-344", "CJJ-II-776"])
    """
    
    def __init__(self, raw = None, **kwargs):
        self.raw = raw

        self.update(**kwargs)
        
    def __getattr__(self, attr): # returns None if attribute doesn't exist
        return None

    def __repr__(self): # for debugging purposes, dumps entire object value
        attrStr = ", ".join([f"{attribute} = {value!r}" for attribute,value in self.__dict__.items()])
        return f"{super().__repr__()}\nDataWrapper({attrStr})"
    
    def update(self, **kwargs):
        for attribute, value in kwargs.items():
            setattr(self, attribute, value)
    
    def parseData(self):
        
        file = self.raw

        if isinstance(file, io.BytesIO): # If file is an UploadedFile (streaming byte data)
            file_stream = io.BytesIO(file.read())  # Wrap file content as a BytesIO object
        elif isinstance(file, (str, Path)): # If file is a Path or string (file path)
            file_stream = open(file, "rb")  # Open file as binary stream
        else:
            raise TypeError("Unsupported file type. Must be an UploadedFile or a Path-like object.")
        
        wavelengths = []
        absorbances = []
        names = []
        
        tree = ET.parse(file_stream)
        root = tree.getroot()
        namespaces = {"ss":"urn:schemas-microsoft-com:office:spreadsheet", 
        "ns0":"urn:schemas-microsoft-com:office:spreadsheet"} # present in all the group's XML files

        series = [series for series in root.findall(".//ns0:Worksheet", namespaces)] # list of each data series

        for worksheet in series:
            wlList = []
            absList = []
            rows = worksheet.findall(".//ns0:Row", namespaces)[1:] # list of all rows skipping first row
            for i,row in enumerate(rows):
                cellsInRow = row.findall("ns0:Cell", namespaces) # returns list of cells for given row
                
                cellData = [cell.find("ns0:Data", namespaces) for cell in cellsInRow] # extracts data from each sell and puts them in list 
                
                # stores first and second sell data to wavelength and absorbance data respectively
                wl = cellData[0]
                absorb = cellData[1]

                # if looking at first row in row list (second row overall as first is skipped), store the third data element as the name
                if i == 0:
                    name = cellData[2]

                # evaluates whether each data value is good to add to the dataset
                try:
                    (int(wl.text), float(absorb.text), str(name.text)) #tests if the .text attribute returns the proper data types
                except:
                    print(f"BAD ROW: ROW #{i+2}") # this'll throw an exception later down the pipes
                    wlValue = "BAD ROW"
                    absValue = "BAD ROW"
                else:
                    wlValue=int(wl.text)
                    absValue=float(absorb.text)
                    nameValue = str(name.text)
                finally:
                    wlList.append(wlValue)
                    absList.append(absValue)

            wavelengths.append(np.array(wlList))
            absorbances.append(np.array(absList))
            names.append(nameValue)
        
        self.x = wavelengths
        self.y = absorbances
        self.names = names

        self.minX = [float(min(x)) for x in self.x] # list of min wavelengths for all traces
        self.maxX = [float(max(x)) for x in self.x] # ditto for maxes

    
    def formatData(self, xRange_in_nm = None, normalize = True, normRange = None, xType = "wavelength", aboveZero = True, inclusion = None):
        
        # this just assigns all the keywords passed to formatData as attributes of the object
        formatAttr = {k:v for k,v in locals().items() if k != "self"}
        self.update(**formatAttr)

        wavelengths = deepcopy(self.x) # deepcopy since its a list of arrays and so formatting doesn't compound
        absorbances = deepcopy(self.y)

        if aboveZero:
            for i,absorb in enumerate(absorbances):
                absorbances[i] -= min(absorb)
                
        # generates a boolean mask for each trace according to the desired *plotting* range
        if xRange_in_nm is not None:
            rangeMasks = []
            for i,wl in enumerate(wavelengths):
                rangeMask = (wl >= xRange_in_nm[0]) & (wl < xRange_in_nm[1])
                rangeMasks.append(rangeMask)
        else: # i.e. to plot whole domain
            rangeMasks = []
            for wl in wavelengths:
                rangeMasks.append(np.array([True for i in range(len(wl))])) # just makes each mask array([T,T,...,T]) for each array
            
        # generates a boolean mask for each trace according to the desired *normalization* range 
        normMasks = []
        if normRange is not None:
            for i,wl in enumerate(wavelengths):
                if type(normRange[0]) in [int, float]: # case where one norm range for all traces
                    normMask = (wl >= normRange[0]) & (wl <= normRange[1])
                    normMasks.append(normMask)
                    normRange = [normRange for i in range(len(wavelengths))] # if normRange is a single range (a,b), this redefines it do be list((a,b)), makes things easier down the line
                
                else: # i.e. if each trace has its own norm range
                    normMask = (wl >= normRange[i][0]) & (wl < normRange[i][1])
                    normMasks.append(normMask)
        else:
            for wl in wavelengths:
                    allMask = np.array([True for i in range(len(wl))]) # creates bool mask that is [T,T,..,T] as long as each wl trace, selects entire wl range
                    normMasks.append(allMask)   
        
        if normalize:
            maxWLs = []
        
            for i, absorb in enumerate(absorbances):
                maxAbsorb = absorb[(normMasks[i]) & (~np.isnan(absorb))].max() # looks for max item of masked absorbance array, skipping nans
                
                absorbances[i] = absorb/maxAbsorb # scaling (doing the actual normalization)

                # adding max norm points to list
                indexArray = np.where(absorb == maxAbsorb)
                for index in indexArray:
                    if normRange is None:
                        maxWL = wavelengths[i][index].item()
                    elif (wavelengths[i][index] >= normRange[i][0]) and (wavelengths[i][index] < normRange[i][1]): # checks if max wavelength is in norm range, this is where it made things easier down the line
                        maxWL = wavelengths[i][index].item()

                maxWLs.append(maxWL)

        else:
            maxWLs = None

        # slicing the wavelength and absorbance arrays to plotting range
        for i,rangeMask in enumerate(rangeMasks):
            wavelengths[i] = wavelengths[i][rangeMask]
            absorbances[i] = absorbances[i][rangeMask]
        
        plotX = list(wavelengths) # b/c numpy arrays are scary
        plotY = list(absorbances)

        # transforms wavelength x-data into proper units (match case since its easier to add more units if desired)
        match xType:
            case "wavelength":
                self.units = "wavelength"

            case "wavenumbers":
                for i,wn in enumerate(plotX):
                    plotX[i] = (10**7)/wn #cm^-1
                    
                    if maxWLs is not None:
                        maxWLs[i] = (10**7)/maxWLs[i]
                
                self.units = "wavenumbers"

            case "electronvolts":
                for i,eV in enumerate(plotX):
                    plotX[i] = (cnst.h * cnst.c * (10**9))/(cnst.e * eV) #eV

                    if maxWLs is not None:
                        maxWLs[i] =  (cnst.h * cnst.c * (10**9))/(cnst.e * maxWLs[i])
                
                self.units = "electronvolts"

        plotDataSeries = [plotX, plotY, maxWLs, self.names]
        if inclusion is not None:
            for i,series in enumerate(plotDataSeries):
                
                if series is maxWLs:
                    if maxWLs is None:
                        continue

                temp = []
                for include,trace in zip(inclusion, series): # applying inclusion mask
                    if include:
                        temp.append(trace)
                    else:
                        continue

                plotDataSeries[i] = temp
        
        self.plotX, self.plotY, self.maxWLs, self.names= plotDataSeries

    def makeFolder(self):
        zip_buffer = io.BytesIO()

        units_y = f"absorbance{" (normalized)" if self.normalize else ""}"

        with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zipFile:
            for i, (traceX, traceY) in enumerate(zip(self.plotX, self.plotY)):
                
                df = pd.DataFrame({f"{self.xAxisTitle}": traceX, f"{units_y}": traceY}) # writing data as dataframe w/ unit headers
                
                csv_buffer = io.StringIO()
                df.to_csv(csv_buffer, index = False) # push dataframe to string buffer

                # info about formatting
                footer = f"\nName,{self.names[i]}\nNormalized?,{self.normalize}\nMax X-Value,{self.maxWLs[i] if self.maxWLs is not None else ""}\nMinimized to 0?,{self.aboveZero}"
                
                csv_buffer.seek(0, io.SEEK_END) # making sure pointer is at end
                csv_buffer.write(footer)
                
                csv_buffer.seek(0) # resetting pointer for reading
                zipFile.writestr(f"{self.names[i]}.csv", csv_buffer.getvalue())
        
        zip_buffer.seek(0) # ditto
        
        self._zipFile = zip_buffer
        
        return zip_buffer

    @property
    def zipFile(self):
        self._zipFile.seek(0) # just to avoid headache
        return self._zipFile

class Plotter:
    """
    Plotter takes in a DataWrapper object and return plots for each trace and main plot

    Constructor:
        Plotter(dataObj: DataWrapper, **kwargs)
            dataObj: DataWrapper object containing formatted data
            **kwargs: extra keyword arguments to save to object as attributes at construction-time
    
    Attributes:
        dataObj (DataWrapper): contains formatted data
        plotTitles (list of str): list of journal entry namesassociated with data
        miniPlots (list of Plotly figures): list of figures for each trace, used to select norm ranges
        units (str): abbreviated units (nm, eV, etc.)
        xAxisTitle (str): title for x-axis according to units (e.g. "wavelength (nm)")
        mainFig (Plotly figure): final main figure
    
    Methods:
        update(**kwargs): updates/sets attribute corresponding to keyword in kwargs to specified value
        
        updateUnits: checks units in dataObj and sets Plotter units accordingly
        
        updateMiniPlot: updates normalization bounds on mini plot
            Required arguments:
                index (int):
                    denotes which trace to affect
            Keyword arguments:
                normRange (list, tuple, or numpy.array, or None, default: None):
                    denotes normalization range to display,
                    if None, no bounds are shown
        
        updateMainPlot: updates main plot with normalization and plotting bounds and which traces to include
    """
    
    def __init__(self, dataObj, **kwargs):
        self.dataObj = dataObj
        self.update(**kwargs)

        plotTitles = []
        for name in self.dataObj.names:
            segments = name.split("-")
            title = "-".join(segments[0:3]) # journal entries are the first three entries (e.g. "CJJ", "II", "021")
            if title not in plotTitles: # only unique journal entries
                plotTitles.append(title)
        
        self.plotTitles = plotTitles

        self.miniPlots = []
        for xData,yData in zip(self.dataObj.x, self.dataObj.y):
            fig = make_subplots()
            fig.add_scatter(x = xData, y = yData, mode = "lines", showlegend = False)
            fig.update_xaxes(title = "Wavelength(nm)")
            fig.update_yaxes(title = "Absorbance")
            fig.update_layout(template = "simple_white")

            self.miniPlots.append(fig)

    def __getattr__(self, attr): # returns None if attribute doesn't exist
        return None
    
    def __repr__(self):
        attrStr = ", ".join([f"{attribute} = {value!r}" for attribute,value in self.__dict__.items()])
        return f"{super().__repr__()}\nPlotter({attrStr})"
    
    def update(self, **kwargs):
        for attribute, value in kwargs.items():
            setattr(self, attribute, value)
    
    def updateUnits(self):
        match self.dataObj.units: # assigning Plotter.units against dataWrapper.units, these units will be used in the plot itself
            case "wavelength":
                self.units = "nm"
                self.xAxisTitle = "wavelength (nm)"
            case "wavenumbers":
                self.units = "cm<sup>-1</sup>"
                self.xAxisTitle = "wavenumbers (cm<sup>-1</sup>)"
            case "electronvolts":
                self.units = "eV"
                self.xAxisTitle = "energy (eV)"

    def updateMiniPlot(self, index, normRange = None):
        fig = self.miniPlots[index]
        fig["layout"]["shapes"] = [] # removes all previous vertical lines from fig

        if normRange is not None:
            normLeft, normRight = normRange
            fig.add_shape(x0 = normLeft, x1 = normLeft, y0 = 0, y1 = 1, xref = "x", yref = "paper", type = "line", line = dict(color = "orange", dash = "dash", width = 2), opacity = 0.8) # left bound
            fig.add_shape(x0 = normRight, x1 = normRight, y0 = 0, y1 = 1, xref = "x", yref = "paper", type = "line", line = dict(color = "orange", dash = "dash", width = 2), opacity = 0.8) # right bound

    def updateMainPlot(self):
        self.updateUnits()

        fig = make_subplots()
        colors = pc.qualitative.Plotly # it is a good color palette tho
        traceColors = [colors[i % len(colors)] for i in range(len(self.dataObj.plotX))] # assigns a color to each trace, loops around if not enough colors
        
        for i, (color, wl, absorb) in enumerate(zip(traceColors, self.dataObj.plotX, self.dataObj.plotY)): # adding each data trace
            fig.add_scatter(x = wl, y = absorb, mode = "lines", line = dict(color = color), showlegend = True, legendgroup = str(i))
        
        if self.dataObj.normalize is True: # displaying max absorb in norm range
            for i, (name, maxWL, color) in enumerate(zip(self.dataObj.names, self.dataObj.maxWLs, traceColors)):
                fig.update_traces(selector = i, name = f"{name}<br>max absorb @ {maxWL:.2f} {self.units}")
        else:
             for i, (name, color) in enumerate(zip(self.dataObj.names, traceColors)):
                fig.update_traces(selector = i, name = name)
        
        fig.update_xaxes(title = self.xAxisTitle) # adding x-axis title
        
        if self.dataObj.normalize is True:
            fig.update_yaxes(title = "absorbance<br>(normalized)", range = [0,1.1])
        else:
            fig.update_yaxes(title = "absorbance")
        
        fig.update_layout(template = "simple_white", title = f"{", ".join(self.plotTitles)}", title_x = 0.5, title_xanchor = "center") # joining plot titles with commas

        self.mainFig = fig

# test case
if __name__ == "__main__":
    data = DataWrapper(raw = r"G:\Shared drives\Chemistry_LipshultzGroup\Data\Alumni\ALM\ALM-I-UV_VIS\ALM-I-279\RAW DATA\ALM-I-279.xml")
    data.parseData()
    data.formatData(xRange_in_nm = None, normalize = True)
    plotter = Plotter(data)
    plotter.updateMainPlot()
    plotter.mainFig.show()
